import { Buffer } from 'buffer';
import { deserializeArrayFromVector, deserializeField, serializeBufferArrayToVector } from '../../serialize.js';
/**
 * Hashes two arrays.
 * @param wasm - The barretenberg module.
 * @param lhs - The first array.
 * @param rhs - The second array.
 * @returns The new 32-byte hash.
 * @deprecated Don't call pedersen directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export function pedersenHash(wasm, lhs, rhs) {
    return pedersenHashWithHashIndex(wasm, [Buffer.from(lhs), Buffer.from(rhs)], 0);
}
/**
 * Computes the hash of an array of buffers.
 * @param wasm - The barretenberg module.
 * @param inputs - The array of buffers to hash.
 * @returns The new 32-byte hash.
 * @deprecated Don't call pedersen directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export function pedersenHashInputs(wasm, inputs) {
    return pedersenHashWithHashIndex(wasm, inputs, 0);
}
/**
 * Hashes an array of buffers.
 * @param wasm - The barretenberg module.
 * @param inputs - The array of buffers to hash.
 * @param hashIndex - Hash index of the generator to use (See GeneratorIndex enum).
 * @returns The resulting 32-byte hash.
 * @deprecated Don't call pedersen directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export function pedersenHashWithHashIndex(wasm, inputs, hashIndex) {
    // If not done already, precompute constants.
    wasm.call('pedersen__init');
    const data = serializeBufferArrayToVector(inputs);
    // WASM gives us 1024 bytes of scratch space which we can use without
    // needing to allocate/free it ourselves. This can be useful for when we need to pass in several small variables
    // when calling functions on the wasm, however it's important to not overrun this scratch space as otherwise
    // the written data will begin to corrupt the stack.
    //
    // Using this scratch space isn't particularly safe if we have multiple threads interacting with the wasm however,
    // each thread could write to the same pointer address simultaneously.
    const SCRATCH_SPACE_SIZE = 1024;
    // For pedersen hashing, the case of hashing two inputs is the most common.
    // so ideally we want to optimize for that. This will use 64 bytes of memory and
    // can thus be optimized by checking if the input buffer is smaller than the scratch space.
    let inputPtr = 0;
    if (inputs.length >= SCRATCH_SPACE_SIZE) {
        inputPtr = wasm.call('bbmalloc', data.length);
    }
    wasm.writeMemory(inputPtr, data);
    // Since the output is 32 bytes, instead of allocating memory
    // we can reuse the scratch space to store the result.
    const outputPtr = 0;
    wasm.call('pedersen__compress_with_hash_index', inputPtr, hashIndex, outputPtr);
    const hashOutput = wasm.getMemorySlice(0, 32);
    wasm.call('bbfree', inputPtr);
    return Buffer.from(hashOutput);
}
/**
 * Given a buffer containing 32 byte pedersen leaves, return a new buffer containing the leaves and all pairs of nodes
 * that define a merkle tree.
 *
 * E.g.
 * Input:  [1][2][3][4]
 * Output: [1][2][3][4][hash(1,2)][hash(3,4)][hash(5,6)].
 *
 * @param wasm - The barretenberg module.
 * @param values - The 32 byte pedersen leaves.
 * @returns A tree represented by an array.
 * @deprecated Don't call pedersen directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export function pedersenGetHashTree(wasm, values) {
    // If not done already, precompute constants.
    wasm.call('pedersen__init');
    const data = serializeBufferArrayToVector(values);
    const inputPtr = wasm.call('bbmalloc', data.length);
    wasm.writeMemory(inputPtr, data);
    wasm.call('pedersen_hash_to_tree', inputPtr, 0);
    const resultPtr = Buffer.from(wasm.getMemorySlice(0, 4)).readUInt32LE(0);
    // First 4 bytes is full response length in byters.
    // Second 4 bytes is vector length in fields.
    const resultNumFields = Buffer.from(wasm.getMemorySlice(resultPtr + 4, resultPtr + 8)).readUInt32BE(0);
    const resultData = Buffer.from(wasm.getMemorySlice(resultPtr + 4, resultPtr + 8 + resultNumFields * 32));
    wasm.call('bbfree', inputPtr);
    wasm.call('bbfree', resultPtr);
    return deserializeArrayFromVector(deserializeField, resultData).elem;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVkZXJzZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnL2NyeXB0by9wZWRlcnNlbi9wZWRlcnNlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRWhDLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxnQkFBZ0IsRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRWhIOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUFpQixFQUFFLEdBQWUsRUFBRSxHQUFlO0lBQzlFLE9BQU8seUJBQXlCLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbEYsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsSUFBaUIsRUFBRSxNQUFnQjtJQUNwRSxPQUFPLHlCQUF5QixDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLHlCQUF5QixDQUFDLElBQWlCLEVBQUUsTUFBZ0IsRUFBRSxTQUFpQjtJQUM5Riw2Q0FBNkM7SUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTVCLE1BQU0sSUFBSSxHQUFHLDRCQUE0QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWxELHFFQUFxRTtJQUNyRSxnSEFBZ0g7SUFDaEgsNEdBQTRHO0lBQzVHLG9EQUFvRDtJQUNwRCxFQUFFO0lBQ0Ysa0hBQWtIO0lBQ2xILHNFQUFzRTtJQUN0RSxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQztJQUVoQywyRUFBMkU7SUFDM0UsZ0ZBQWdGO0lBQ2hGLDJGQUEyRjtJQUMzRixJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLGtCQUFrQixFQUFFO1FBQ3ZDLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDL0M7SUFDRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUVqQyw2REFBNkQ7SUFDN0Qsc0RBQXNEO0lBQ3RELE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBQztJQUVwQixJQUFJLENBQUMsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDaEYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFOUIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2pDLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBTSxVQUFVLG1CQUFtQixDQUFDLElBQWlCLEVBQUUsTUFBZ0I7SUFDckUsNkNBQTZDO0lBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUM1QixNQUFNLElBQUksR0FBRyw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFFakMsSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RSxtREFBbUQ7SUFDbkQsNkNBQTZDO0lBQzdDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2RyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxHQUFHLGVBQWUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRS9CLE9BQU8sMEJBQTBCLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3ZFLENBQUMifQ==