/**
 * Decodes return values from a function call.
 * Missing support for integer and string.
 */
class ReturnValuesDecoder {
    constructor(artifact, flattened) {
        this.artifact = artifact;
        this.flattened = flattened;
    }
    /**
     * Decodes a single return value from field to the given type.
     * @param abiType - The type of the return value.
     * @returns The decoded return value.
     */
    decodeReturn(abiType) {
        switch (abiType.kind) {
            case 'field':
                return this.getNextField().value;
            case 'integer':
                if (abiType.sign === 'signed') {
                    throw new Error('Unsupported type: signed integer');
                }
                return this.getNextField().value;
            case 'boolean':
                return !this.getNextField().isZero();
            case 'array': {
                const array = [];
                for (let i = 0; i < abiType.length; i += 1) {
                    array.push(this.decodeReturn(abiType.type));
                }
                return array;
            }
            case 'struct': {
                const struct = {};
                for (const field of abiType.fields) {
                    struct[field.name] = this.decodeReturn(field.type);
                }
                return struct;
            }
            default:
                throw new Error(`Unsupported type: ${abiType.kind}`);
        }
    }
    /**
     * Gets the next field in the flattened return values.
     * @returns The next field in the flattened return values.
     */
    getNextField() {
        const field = this.flattened.shift();
        if (!field) {
            throw new Error('Not enough return values');
        }
        return field;
    }
    /**
     * Decodes all the return values for the given function ABI.
     * Aztec.nr support only single return value
     * The return value can however be simple types, structs or arrays
     * @returns The decoded return values.
     */
    decode() {
        if (this.artifact.returnTypes.length > 1) {
            throw new Error('Multiple return values not supported');
        }
        if (this.artifact.returnTypes.length === 0) {
            return [];
        }
        return this.decodeReturn(this.artifact.returnTypes[0]);
    }
}
/**
 * Decodes return values from a function call.
 * @param abi - The ABI entry of the function.
 * @param returnValues - The decoded return values.
 * @returns
 */
export function decodeReturnValues(abi, returnValues) {
    return new ReturnValuesDecoder(abi, returnValues.slice()).decode();
}
/**
 * Decodes the signature of a function from the name and parameters.
 */
export class FunctionSignatureDecoder {
    constructor(name, parameters, includeNames = false) {
        this.name = name;
        this.parameters = parameters;
        this.includeNames = includeNames;
        this.separator = includeNames ? ', ' : ',';
    }
    /**
     * Decodes a single function parameter type for the function signature.
     * @param param - The parameter type to decode.
     * @returns A string representing the parameter type.
     */
    getParameterType(param) {
        switch (param.kind) {
            case 'field':
                return 'Field';
            case 'integer':
                if (param.sign === 'signed') {
                    throw new Error('Unsupported type: signed integer');
                }
                return `u${param.width}`;
            case 'boolean':
                return 'bool';
            case 'array':
                return `[${this.getParameterType(param.type)};${param.length}]`;
            case 'struct':
                return `(${param.fields.map(field => `${this.decodeParameter(field)}`).join(this.separator)})`;
            default:
                throw new Error(`Unsupported type: ${param.kind}`);
        }
    }
    /**
     * Decodes a single function parameter for the function signature.
     * @param param - The parameter to decode.
     * @returns A string representing the parameter type and optionally its name.
     */
    decodeParameter(param) {
        const type = this.getParameterType(param.type);
        return this.includeNames ? `${param.name}: ${type}` : type;
    }
    /**
     * Decodes all the parameters and build the function signature
     * @returns The function signature.
     */
    decode() {
        return `${this.name}(${this.parameters.map(param => this.decodeParameter(param)).join(this.separator)})`;
    }
}
/**
 * Decodes a function signature from the name and parameters.
 * @param name - The name of the function.
 * @param parameters - The parameters of the function.
 * @returns - The function signature.
 */
export function decodeFunctionSignature(name, parameters) {
    return new FunctionSignatureDecoder(name, parameters).decode();
}
/**
 * Decodes a function signature from the name and parameters including parameter names.
 * @param name - The name of the function.
 * @param parameters - The parameters of the function.
 * @returns - The user-friendly function signature.
 */
export function decodeFunctionSignatureWithParameterNames(name, parameters) {
    return new FunctionSignatureDecoder(name, parameters, true).decode();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmkvZGVjb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQTs7O0dBR0c7QUFDSCxNQUFNLG1CQUFtQjtJQUN2QixZQUFvQixRQUEwQixFQUFVLFNBQWU7UUFBbkQsYUFBUSxHQUFSLFFBQVEsQ0FBa0I7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFNO0lBQUcsQ0FBQztJQUUzRTs7OztPQUlHO0lBQ0ssWUFBWSxDQUFDLE9BQWdCO1FBQ25DLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRTtZQUNwQixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsS0FBSyxDQUFDO1lBQ25DLEtBQUssU0FBUztnQkFDWixJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7aUJBQ3JEO2dCQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLEtBQUssQ0FBQztZQUNuQyxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN2QyxLQUFLLE9BQU8sQ0FBQyxDQUFDO2dCQUNaLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztnQkFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDMUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUM3QztnQkFDRCxPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixNQUFNLE1BQU0sR0FBcUMsRUFBRSxDQUFDO2dCQUNw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