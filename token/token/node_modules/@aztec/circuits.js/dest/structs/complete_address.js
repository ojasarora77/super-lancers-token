import { AztecAddress } from '@aztec/foundation/aztec-address';
import { Fr, Point } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { computeContractAddressFromPartial } from '../abis/abis.js';
import { Grumpkin } from '../barretenberg/index.js';
import { CircuitsWasm } from '../index.js';
/**
 * A complete address is a combination of an Aztec address, a public key and a partial address.
 *
 * @remarks We have introduced this type because it is common that these 3 values are used together. They are commonly
 *          used together because it is the information needed to send user a note.
 * @remarks See the link bellow for details about how address is computed:
 *          https://github.com/AztecProtocol/aztec-packages/blob/master/docs/docs/concepts/foundation/accounts/keys.md#addresses-partial-addresses-and-public-keys
 */
export class CompleteAddress {
    // TODO: This constructor should be private so that the check in create method is always enforced. However, this is
    //       not possible now because we need the class to be compatible with `StringIOClass` to be able to pass it
    //       through `JsonRpcServer`.
    constructor(
    /** Contract address (typically of an account contract) */
    address, 
    /** Public key corresponding to the address (used during note encryption). */
    publicKey, 
    /** Partial key corresponding to the public key to the address. */
    partialAddress) {
        this.address = address;
        this.publicKey = publicKey;
        this.partialAddress = partialAddress;
    }
    static async create(address, publicKey, partialAddress) {
        const wasm = await CircuitsWasm.get();
        const expectedAddress = computeContractAddressFromPartial(wasm, publicKey, partialAddress);
        if (!expectedAddress.equals(address)) {
            throw new Error(`Address cannot be derived from pubkey and partial address (received ${address.toString()}, derived ${expectedAddress.toString()})`);
        }
        return new CompleteAddress(address, publicKey, partialAddress);
    }
    static async random() {
        const partialAddress = Fr.random();
        const pubKey = Point.random();
        const wasm = await CircuitsWasm.get();
        const address = computeContractAddressFromPartial(wasm, pubKey, partialAddress);
        return new CompleteAddress(address, pubKey, partialAddress);
    }
    static async fromPrivateKeyAndPartialAddress(privateKey, partialAddress) {
        const wasm = await CircuitsWasm.get();
        const grumpkin = new Grumpkin(wasm);
        const pubKey = grumpkin.mul(Grumpkin.generator, privateKey);
        const address = computeContractAddressFromPartial(wasm, pubKey, partialAddress);
        return new CompleteAddress(address, pubKey, partialAddress);
    }
    /**
     * Gets a readable string representation of a the complete address.
     * @returns A readable string representation of the complete address.
     */
    toReadableString() {
        return ` Address: ${this.address.toString()}\n Public Key: ${this.publicKey.toString()}\n Partial Address: ${this.partialAddress.toString()}\n`;
    }
    /**
     * Determines if this CompleteAddress instance is equal to the given CompleteAddress instance.
     * Equality is based on the content of their respective buffers.
     *
     * @param other - The CompleteAddress instance to compare against.
     * @returns True if the buffers of both instances are equal, false otherwise.
     */
    equals(other) {
        return (this.address.equals(other.address) &&
            this.publicKey.equals(other.publicKey) &&
            this.partialAddress.equals(other.partialAddress));
    }
    /**
     * Converts the CompleteAddress instance into a Buffer.
     * This method should be used when encoding the address for storage, transmission or serialization purposes.
     *
     * @returns A Buffer representation of the CompleteAddress instance.
     */
    toBuffer() {
        return Buffer.concat([this.address.toBuffer(), this.publicKey.toBuffer(), this.partialAddress.toBuffer()]);
    }
    /**
     * Creates an CompleteAddress instance from a given buffer or BufferReader.
     * If the input is a Buffer, it wraps it in a BufferReader before processing.
     * Throws an error if the input length is not equal to the expected size.
     *
     * @param buffer - The input buffer or BufferReader containing the address data.
     * @returns - A new CompleteAddress instance with the extracted address data.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const address = reader.readObject(AztecAddress);
        const publicKey = reader.readObject(Point);
        const partialAddress = reader.readObject(Fr);
        return new this(address, publicKey, partialAddress);
    }
    /**
     * Create a CompleteAddress instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param address - The hex-encoded string representing the complete address.
     * @returns A Point instance.
     */
    static fromString(address) {
        return this.fromBuffer(Buffer.from(address.replace(/^0x/i, ''), 'hex'));
    }
    /**
     * Convert the CompleteAddress to a hexadecimal string representation, with a "0x" prefix.
     * The resulting string will have a length of 66 characters (including the prefix).
     *
     * @returns A hexadecimal string representation of the CompleteAddress.
     */
    toString() {
        return `0x${this.toBuffer().toString('hex')}`;
    }
}
/** Size in bytes of an instance */
CompleteAddress.SIZE_IN_BYTES = 32 * 4;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxldGVfYWRkcmVzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdHJ1Y3RzL2NvbXBsZXRlX2FkZHJlc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTNELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsWUFBWSxFQUFpRCxNQUFNLGFBQWEsQ0FBQztBQUUxRjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLGVBQWU7SUFDMUIsbUhBQW1IO0lBQ25ILCtHQUErRztJQUMvRyxpQ0FBaUM7SUFDakM7SUFDRSwwREFBMEQ7SUFDbkQsT0FBcUI7SUFDNUIsNkVBQTZFO0lBQ3RFLFNBQW9CO0lBQzNCLGtFQUFrRTtJQUMzRCxjQUE4QjtRQUo5QixZQUFPLEdBQVAsT0FBTyxDQUFjO1FBRXJCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFFcEIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO0lBQ3BDLENBQUM7SUFLSixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FDakIsT0FBcUIsRUFDckIsU0FBb0IsRUFDcEIsY0FBOEI7UUFFOUIsTUFBTSxJQUFJLEdBQUcsTUFBTSxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEMsTUFBTSxlQUFlLEdBQUcsaUNBQWlDLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUMzRixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNwQyxNQUFNLElBQUks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